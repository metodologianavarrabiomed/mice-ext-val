#' Calculates Harrell C-Index for a model
#'
#' @description
#' This function calculates the Harrell C Index value of a `model` in each of the imputed dataset stored in `data` as a long dataset. The Harrell's C Index calculation is realized using the [Hmisc::rcorr.cens()] function of the Harrell's package `Hmisc`. After calculating the index in each imputed dataset then it aggregates them using the rubin rules with the [psfmi::pool_RR()] function of the Heymans' package `psfmi`. Finally, it stores the result inside the `results_imp` and `results_agg` attributes of the `model`.
#'
#' @references
#'  F. E. Harrell, “Harrell Miscellaneous (R package Hmisc version 5.1-1),” R-project.org, Sep. 2023, doi: <https://cran.r-project.org/package=Hmisc>.
#'  M. Heymans, “Prediction Model Pooling, Selection and Performance Evaluation Across Multiply Imputed Datasets (R package psfmi version 1.4.0),” R-project.org, Jun. 2023, doi: <https://cran.r-project.org/package=psfmi>.
#'
#' @param model A model generated by the function [mv_model_cox()] or [mv_model_logreg()]
#' @param data Multiple imputation data organized as a long dataset
#' @param .progress `TRUE` to render the progress bar `FALSE` otherwise
#'
#' @return The same `model` passed as a parameter with the Harrell C Index value stored in `results_agg` and `results_imp`
#'
#' @export
#'
#' @examples
#' set.seed(123)
#'
#' model <- mv_model_logreg(formula = event ~ 0.5 * x + 0.3 * z - 1.2)
#'
#' data <- data.frame(
#'   .imp = c(1, 1, 1, 2, 2, 2, 3, 3, 3),
#'   id = c(1, 2, 3, 1, 2, 3, 1, 2, 3),
#'   x = rnorm(9, 1, 0.25),
#'   z = rnorm(9, 2, 0.75),
#'   event = survival::Surv(rpois(9, 5), rbinom(n = 9, size = 1, prob = 0.2))
#' )
#'
#' model <- model |>
#'   calculate_predictions(data) |>
#'   calculate_harrell_c_index(data)
calculate_harrell_c_index <- function(model, data, .progress = FALSE) {
  error_message <- NULL

  if (!methods::is(model, "MiceExtVal")) {
    error_message <- c(error_message, "*" = cli::format_error("{.arg model} must be {.cls MiceExtVal}"))
  }
  if (!methods::is(data, "data.frame")) {
    error_message <- c(error_message, "*" = cli::format_error("{.arg data} must be {.cls data.frame}"))
  } else {
    if (!".imp" %in% colnames(data)) {
      error_message <- c(error_message, "*" = cli::format_error("{.arg data} must contain {.arg .imp}"))
    }

    if (!"predictions_imp" %in% names(model)) {
      error_message <- c(error_message, "*" = cli::format_error("{.arg model} must contain {.arg predictions_imp} calculate it with {.fun MiceExtval::calculate_predictions}"))
    }

    if (!"formula" %in% names(model)) {
      error_message <- c(error_message, "*" = cli::format_error("{.arg model} must contain a valid {.arg formula}"))
    } else {
      dependent_variable <- all.vars(model[["formula"]])[1]
      if (!dependent_variable %in% colnames(data)) {
        error_message <- c(error_message, "*" = cli::format_error("the dependent variable {.var {dependent_variable}} must be part of {.arg data}"))
      }
      if (!methods::is(data[[dependent_variable]], "Surv")) {
        error_message <- c(error_message, "*" = cli::format_error("the dependent variable {.var {dependent_variable}} must be {.cls Surv}"))
      }
    }
  }

  if (!is.null(error_message)) cli::cli_abort(error_message)

  # Code for the progress bar
  if (.progress) {
    env <- rlang::env()
    cli::cli_progress_step("calculating c-index", spinner = TRUE, .envir = env)
  }

  # Calculates the C-Index value in each of the imputations.
  c_index_data <- data |>
    dplyr::group_by_at(dplyr::vars(".imp")) |>
    dplyr::group_map(~ {
      # Obtain the data of the event variable
      survival_data <- .x[[all.vars(model[["formula"]])[1]]]

      # Progress bar code
      if (.progress) {
        cli::cli_progress_update(.envir = env)
      }

      c_index <- Hmisc::rcorr.cens(
        # Get the predictions data for the imputation `.imp`.
        x = 1 - (model[["predictions_imp"]] |> dplyr::filter({
          .imp == .y[[".imp"]]
        }) |> dplyr::pull(var = "prediction")),
        # Generates the outcome variable from `survival_data`
        S = survival::Surv(time = survival_data[, "time"], event = survival_data[, "status"])
      )

      tibble::tibble(
        .imp = .y[[".imp"]],
        estimate = c_index["C Index"],
        se = c_index["S.D."] / 2
      )
    }) |>
    dplyr::bind_rows()

  model[["results_imp"]] <- dplyr::bind_rows(
    model[["results_imp"]],
    c_index_data |> tibble::add_column(name = "harrell_c_index", .before = ".imp")
  )

  if (.progress) {
    cli::cli_progress_done(.envir = env)
    cli::cli_progress_step("pooling c-index with rubin rules", spinner = TRUE, .envir = env)
  }

  n <- data |>
    dplyr::filter(.data[[".imp"]] == 1) |>
    dplyr::pull("id") |>
    length()

  # Aggregates the results using rubin rules and populates the `c_index` parameter in the model
  c_index_agg <- psfmi::pool_RR(
    est = c_index_data[["estimate"]],
    se = c_index_data[["se"]],
    n = n,
    k = 1
  )

  model[["results_agg"]] <- dplyr::bind_rows(
    model[["results_agg"]],
    tibble::tibble(
      name = "harrell_c_index",
      estimate = c_index_agg[["Estimate"]],
      lower = c_index_agg[["95% CI L"]],
      upper = c_index_agg[["95% CI U"]],
      p_val = c_index_agg[["P-val"]]
    )
  )

  if (.progress) {
    cli::cli_progress_done(.envir = env)
  }

  return(model)
}
