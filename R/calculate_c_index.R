#' Calculates Harrell C-Index for a model
#'
#' @description
#' This function calculates the Harrell C Index value of a `model` in each of the imputed dataset stored in `data` as a long dataset. The Harrell's C Index calculation is realized using the `Hmisc::rcorr.cens` function of the Harrell's package `Hmisc`. After calculating the index in each imputed dataset then it aggregates them using the rubin rules with the `psfmi::pool_RR` function of the Heymans' package `psfmi`. Finally, it stores the result inside the `c_index` attribute of the `model`.
#'
#' @references
#'  F. E. Harrell, “Harrell Miscellaneous (R package Hmisc version 5.1-1),” R-project.org, Sep. 2023, doi: <https://cran.r-project.org/package=Hmisc>.
#'  M. Heymans, “Prediction Model Pooling, Selection and Performance Evaluation Across Multiply Imputed Datasets (R package psfmi version 1.4.0),” R-project.org, Jun. 2023, doi: <https://cran.r-project.org/package=psfmi>.
#'
#' @param model A model generated by the function [mv_model_cox()] or [mv_model_logreg()]
#' @param data Multiple imputation data organized as a long dataset
#' @param .progress `TRUE` to render the progress bar `FALSE` otherwise
#'
#' @return The same `model` passed as a parameter with the Harrell C Index value stored in `$c_index`
#'
#' @importFrom Hmisc rcorr.cens
#' @importFrom dplyr %>% group_by group_map filter select
#' @importFrom tibble tibble as_tibble
#' @importFrom progress progress_bar
#' @importFrom methods is
#'
#' @export
#'
#' @examples
#' set.seed(123)
#'
#' model <- mv_model_logreg(
#'   coefficients = list(x = 0.5, z = 0.3),
#'   formula = event ~ x + z,
#'   intercept = 1.2
#' )
#'
#' data <- data.frame(
#'   .imp = c(1,1,1,2,2,2,3,3,3),
#'   id = c(1,2,3,1,2,3,1,2,3),
#'   x = rnorm(9, 1, 0.25),
#'   z = rnorm(9, 2, 0.75),
#'   status = c(1,0,0,1,0,0,1,0,0),
#'   time = c(2,3,5,2,3,5,2,3,5)
#' )
#' data$event <- survival::Surv(data$time, data$status)
#'
#'
#' model <- model |>
#'   calculate_predictions(data) |>
#'   calculate_c_index(data)
calculate_c_index <- function(model, data, .progress = TRUE) {
  stopifnot(methods::is(model, "MiceExtVal"))
  stopifnot(methods::is(data, "data.frame"))

  # Code for the progress bar
  if (.progress) {
    n_iter <- max(data$.imp)
    pb <- progress::progress_bar$new(
      format = "Calculating C-Index \t[:bar] :percent [E.T.: :elapsedfull || R.T.: :eta]",
      total = n_iter,
      complete = "=",
      incomplete = "-",
      current = ">",
      clear = FALSE,
      width = 100
    )
  }

  # Calculates the C-Index value in each of the imputations.
  c_index_data <- data %>%
    dplyr::group_by(.imp) %>%
    dplyr::group_map(~ {
      # Progress bar code
      if (.progress) {
        pb$tick()
      }

      # Obtain the data of the event variable
      survival_data <- .x[[all.vars(model$formula)[1]]]
      Hmisc::rcorr.cens(
        # Get the predictions data for the imputation `.imp`.
        x = unlist(1 - (model$predictions_data %>% dplyr::filter(.imp == .y$.imp) %>% dplyr::select(prediction))),
        # Generates the outcome variable from `survival_data`
        S = survival::Surv(time = survival_data[, "time"], event = survival_data[, "status"])
      )
    }) %>%
    do.call(rbind, args = .)

  # Aggregates the results using rubin rules and populates the `c_index` parameter in the model
  model$c_index <- psfmi::pool_RR(
    est = c_index_data[, "C Index"],
    se = c_index_data[, "S.D."]/2,
    n = c_index_data[1, "n"],
    k = 1
  )

  return(model)
}
