#' Calculates Harrell C-Index for a model
#'
#' @description
#' This function calculates the Harrell C Index value of a `model` in each of the imputed dataset stored in `data` as a long dataset. The Harrell's C Index calculation is realized using the `Hmisc::rcorr.cens` function of the Harrell's package `Hmisc`. After calculating the index in each imputed dataset then it aggregates them using the rubin rules with the `psfmi::pool_RR` function of the Heymans' package `psfmi`. Finally, it stores the result inside the `c_index` attribute of the `model`.
#'
#' @references
#'  F. E. Harrell, “Harrell Miscellaneous (R package Hmisc version 5.1-1),” R-project.org, Sep. 2023, doi: <https://cran.r-project.org/package=Hmisc>.
#'  M. Heymans, “Prediction Model Pooling, Selection and Performance Evaluation Across Multiply Imputed Datasets (R package psfmi version 1.4.0),” R-project.org, Jun. 2023, doi: <https://cran.r-project.org/package=psfmi>.
#'
#' @param model A model generated by the function [mv_model_cox()] or [mv_model_logreg()]
#' @param data Multiple imputation data organized as a long dataset
#' @param .progress `TRUE` to render the progress bar `FALSE` otherwise
#'
#' @return The same `model` passed as a parameter with the Harrell C Index value stored in `$c_index`
#'
#' @importFrom Hmisc rcorr.cens
#' @importFrom dplyr %>% group_by_at group_map filter pull vars
#' @importFrom tibble tibble as_tibble
#' @importFrom progress progress_bar
#' @importFrom methods is
#' @importFrom cli format_error cli_abort
#' @importFrom psfmi pool_RR
#'
#' @export
#'
#' @examples
#' set.seed(123)
#'
#' model <- mv_model_logreg(
#'   coefficients = list(x = 0.5, z = 0.3),
#'   formula = event ~ x + z,
#'   intercept = 1.2
#' )
#'
#' data <- data.frame(
#'   .imp = c(1,1,1,2,2,2,3,3,3),
#'   id = c(1,2,3,1,2,3,1,2,3),
#'   x = rnorm(9, 1, 0.25),
#'   z = rnorm(9, 2, 0.75),
#'   status = c(1,0,0,1,0,0,1,0,0),
#'   time = c(2,3,5,2,3,5,2,3,5)
#' )
#' data$event <- survival::Surv(data$time, data$status)
#'
#'
#' model <- model |>
#'   calculate_predictions(data) |>
#'   calculate_c_index(data)
calculate_c_index <- function(model, data, .progress = FALSE) {
  error_message <- NULL

  if (!methods::is(model, "MiceExtVal")) {
    error_message <- c(error_message, "*" = cli::format_error("{.arg model} must be {.cls MiceExtVal}"))
  }
  if (!methods::is(data, "data.frame")) {
    error_message <- c(error_message, "*" = cli::format_error("{.arg data} must be {.cls data.frame}"))
  } else {
    if (!".imp" %in% colnames(data)) {
      error_message <- c(error_message, "*" = cli::format_error("{.arg data} must contain {.arg .imp}"))
    }

    if (!"predictions_data" %in% names(model)) {
      error_message <- c(error_message, "*" = cli::format_error("{.arg model} must contain {.arg predictions_data} calculate it with {.fun MiceExtval::calculate_predictions}"))
    }

    if (!"formula" %in% names(model)) {
      error_message <- c(error_message, "*" = cli::format_error("{.arg model} must contain a valid {.arg formula}"))
    } else {
      dependent_variable <- all.vars(model$formula)[1]
      if (!dependent_variable %in% colnames(data)) {
        error_message <-  c(error_message, "*" = cli::format_error("the dependent variable {.var {dependent_variable}} must be part of {.arg data}"))
      }
      if (!methods::is(data[[dependent_variable]], "Surv")) {
        error_message <- c(error_message, "*" = cli::format_error("the dependent variable {.var {dependent_variable}} must be {.cls Surv}"))
      }
    }
  }

  if (!is.null(error_message)) cli::cli_abort(error_message)

  # Code for the progress bar
  if (.progress) {
    n_iter <- max(data$.imp)
    pb <- progress::progress_bar$new(
      format = "Calculating C-Index \t[:bar] :percent [E.T.: :elapsedfull || R.T.: :eta]",
      total = n_iter,
      complete = "=",
      incomplete = "-",
      current = ">",
      clear = FALSE,
      width = 100
    )
  }

  # Calculates the C-Index value in each of the imputations.
  c_index_data <- data %>%
    dplyr::group_by_at(dplyr::vars(".imp")) %>%
    dplyr::group_map(~ {
      # Progress bar code
      if (.progress) {
        pb$tick()
      }

      # Obtain the data of the event variable
      survival_data <- .x[[all.vars(model$formula)[1]]]
      Hmisc::rcorr.cens(
        # Get the predictions data for the imputation `.imp`.
        x = 1 - (model$predictions_data %>% dplyr::filter({.imp == .y$.imp}) %>% dplyr::pull(var="prediction")),
        # Generates the outcome variable from `survival_data`
        S = survival::Surv(time = survival_data[, "time"], event = survival_data[, "status"])
      )
    }) %>%
    dplyr::bind_rows()

  # Aggregates the results using rubin rules and populates the `c_index` parameter in the model
  model$c_index <- psfmi::pool_RR(
    est = c_index_data$`C Index`,
    se = c_index_data$`S.D.`/2,
    n = c_index_data$n[[1]],
    k = 1
  )

  return(model)
}
