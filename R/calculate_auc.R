#' calculates the area under the curve for the given model
#'
#' @description
#' This function calculates the Area Under the Curve value for the given model. It uses the [pROC::auc()] function from the `pROC` package.
#' @param model A model generated by the function [mv_model_cox()] or [mv_model_logreg()]
#' @param data Multiple imputed data organized as a long dataset
#' @param .progress `TRUE` to render the progress bar `FALSE` otherwise
#'
#' @importFrom pROC auc var
#' @importFrom methods is
#' @importFrom cli format_error cli_abort
#' @importFrom dplyr group_by_at group_map filter pull bind_rows
#' @importFrom tibble tibble
#' @importFrom psfmi pool_RR
#'
#' @return The same `model` passed as a parameter with the Harrell C Index value stored in `$auc`
#'
#' @export
#'
#' @examples
#' \dontrun{
#' calculate_auc(model, data)
#' }
calculate_auc <- function(model, data, .progress = FALSE) {
  is_dichotomous <- \(x) is.numeric(x) & length(unique(x)) == 2
  error_message <- get_error_message_calculate_recalibrated(model, data)

  if (!methods::is(model, "MiceExtVal")) {
    error_message <- c(error_message, "*" = cli::format_error("{.arg model} must be {.cls MiceExtVal}"))
  }
  if (!methods::is(data, "data.frame")) {
    error_message <- c(error_message, "*" = cli::format_error("{.arg data} must be {.cls data.frame}"))
  } else {
    if (!"predictions_data" %in% names(model)) {
      error_message <- c(error_message, "*" = cli::format_error("{.arg model} must contain {.arg predictions_data} calculate it with {.fun MiceExtval::calculate_predictions}"))
    }

    if (!"formula" %in% names(model)) {
      error_message <- c(error_message, "*" = cli::format_error("{.arg model} must contain a valid {.arg formula}"))
    } else {
      dependent_variable <- all.vars(model$formula)[1]
      if (!dependent_variable %in% colnames(data)) {
        error_message <- c(error_message, "*" = cli::format_error("the dependent variable {.var {dependent_variable}} must be part of {.arg data}"))
      }
    }
  }

  if (!is.null(error_message)) {
    cli::cli_abort(error_message)
  }

  model_auc <- data |>
    dplyr::group_by_at(".imp") |>
    dplyr::group_map(~ {
      # Progress bar code
      if (.progress) {
        cli::cli_progress_update(.envir = env)
      }

      if (methods::is(data[[dependent_variable]], "Surv")) {
        y <- .x[[dependent_variable]][, "status"]
      } else {
        y <- .x[[dependent_variable]]
      }

      predictions <- model$predictions_data |>
        dplyr::filter(.data[[".imp"]] == .y$.imp) |>
        dplyr::pull(var = "prediction")

      auc_val <- suppressMessages(pROC::auc(y, predictions))

      tibble::tibble(
        .imp = .y$.imp,
        auc = auc_val |> as.numeric(),
        se = sqrt(pROC::var(auc_val)) / sqrt(length(predictions))
      )
    }) |>
    dplyr::bind_rows()

  n <- data |>
    dplyr::filter(.data[[".imp"]] == 1) |>
    dplyr::pull("id") |>
    length()

  model$auc <- psfmi::pool_RR(
    est = model_auc[["auc"]],
    se = model_auc[["se"]],
    n = n,
    k = 1
  )

  return(model)
}
