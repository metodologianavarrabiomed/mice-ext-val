#' calculates the area under the curve for the given model
#'
#' @description
#' This function calculates the Area Under the Curve value for the given model. It uses the [pROC::auc()] function from the `pROC` package.
#' @param model A model generated by the function [mv_model_cox()] or [mv_model_logreg()]
#' @param data Multiple imputed data organized as a long dataset
#' @param .progress `TRUE` to render the progress bar `FALSE` otherwise
#'
#' @return The same `model` passed as a parameter with the AUC results stored in `results_imp` and `results_agg`
#'
#' @export
#'
#' @examples
#' \dontrun{
#' calculate_auc(model, data)
#' }
calculate_auc <- function(model, data, .progress = FALSE) {
  is_dichotomous <- \(x) is.numeric(x) & length(unique(x)) == 2
  error_message <- get_error_message_calculate_recalibrated(model, data)

  if (!methods::is(model, "MiceExtVal")) {
    error_message <- c(error_message, "*" = cli::format_error("{.arg model} must be {.cls MiceExtVal}"))
  }
  if (!methods::is(data, "data.frame")) {
    error_message <- c(error_message, "*" = cli::format_error("{.arg data} must be {.cls data.frame}"))
  } else {
    if (!"predictions_imp" %in% names(model)) {
      error_message <- c(error_message, "*" = cli::format_error("{.arg model} must contain {.arg predictions_imp} calculate it with {.fun MiceExtval::calculate_predictions}"))
    }

    if (!"formula" %in% names(model)) {
      error_message <- c(error_message, "*" = cli::format_error("{.arg model} must contain a valid {.arg formula}"))
    } else {
      dependent_variable <- all.vars(model[["formula"]])[1]
      if (!dependent_variable %in% colnames(data)) {
        error_message <- c(error_message, "*" = cli::format_error("the dependent variable {.var {dependent_variable}} must be part of {.arg data}"))
      }
    }
  }

  if (!is.null(error_message)) {
    cli::cli_abort(error_message)
  }

  model_auc <- data |>
    dplyr::group_by_at(".imp") |>
    dplyr::group_map(~ {
      # Progress bar code
      if (.progress) {
        cli::cli_progress_update(.envir = env)
      }

      if (methods::is(data[[dependent_variable]], "Surv")) {
        y <- .x[[dependent_variable]][, "status"]
      } else {
        y <- .x[[dependent_variable]]
      }

      predictions <- model[["predictions_imp"]] |>
        dplyr::filter(.data[[".imp"]] == .y[[".imp"]]) |>
        dplyr::pull(var = "prediction")

      auc_val <- suppressMessages(pROC::auc(y, predictions))

      tibble::tibble(
        .imp = .y[[".imp"]],
        estimate = auc_val |> as.numeric(),
        se = sqrt(pROC::var(auc_val)) / sqrt(length(predictions))
      )
    }) |>
    dplyr::bind_rows()

  model[["results_imp"]] <- dplyr::bind_rows(
    model[["results_imp"]],
    model_auc |>
      tibble::add_column(name = "auc",.before = ".imp")
  )

  n <- data |>
    dplyr::filter(.data[[".imp"]] == 1) |>
    dplyr::pull("id") |>
    length()

  auc <- psfmi::pool_RR(
    est = model_auc[["estimate"]],
    se = model_auc[["se"]],
    n = n,
    k = 1
  )

  model[["results_agg"]] <- dplyr::bind_rows(
    model[["results_agg"]],
    tibble::tibble(
      name = "auc",
      estimate = auc[["Estimate"]],
      lower = auc[["95% CI L"]],
      upper = auc[["95% CI U"]],
      p_val = auc[["P-val"]])
  )

  return(model)
}
